================================================================================
                                   LOADING
================================================================================

    map = load_star_map("sky");               # load data from sky.mkm: stars, nebulae, etc.
    image = new_image();                      # image
    image_list = append(image_list, image);   # {
    image->name = ucsdup("orion");            # name = “orion”;
    image->width = size_value(500,UNIT_PX);   # width = 500px;
    image->height = size_value(500,UNIT_PX);  # height = 500px;
    image->scale = 1.6;                       # scale = 1.6;
    image->projection = new_projection();     # ...
    image->projection->type = Lambert_conic;  # projection.type = Lambert_conic;
    image->projection->alpha = HHMM(5,20);    # projection.α = 5ʰ20ᵐ;
    image->projection->delta = DD(10);        # projection.δ = 10°;
    image->projection->diff_delta = DD(10);   # projection.Δδ = 10°;

    image->projection = 
        new projection {
            type: Lambert_conic, α: 5h20m, δ: 10°, Δδ: 10°
        };

    draw_map(image);

--------------------------------------------------------------------------------

Block assignment:

    image->projection =
        new projection {
            type: Lambert_conic, α: 5h20m, δ: 10°, Δδ: 10°
        };

problem:

    overwrites already set values with those set in the default 

alternate interpretation:

    image->projection = new projection;
    with image->projection = IP do {
        IP.type = Lambert_conic;
        IP.α = 5h20m;
        IP.δ = 10°;
        IP.Δδ = 10°;
    }

================================================================================
                          THE PRINCIPLE OF STREAMING
================================================================================
                                in principle
--------------------------------------------------------------------------------
starDB     =  datafile(“star.DB”);
stars      =  starDB -> select(ID, RA, DE, vmag) -> less(vmag,6.5);
starnames  =  starDB -> select(ID, name);
stardesgs  =  starDB -> select(ID, desg);
galaxies   =  datafile(“galaxy.DB”)
           -> select(RA, DE, vmag, size)
           -> less(vmag,10.0);
orionSky   =  (stars, galaxies)             # from stars and then galaxies,
           -> symbology(Tirion);            # add Will Tirion style symbols
orionFrame =  projection(Lambert_conformal,5ʰ20ᵐ,10°,10°) -> frame(500px,500px);
orionMap   =  (constellationBorders,        # 1st: draw constellationBorders
               declinationGrid(10°),        # 2nd: declination grid
               rectascentionGrid(1ʰ),       # 3rd: rectascention grid
               orionSky)                    # 4th: the sky as per above
           -> orionFrame;                   # F.ex.
image      =  (background + orionMap)
           -> SVGconverter;
--------------------------------------------------------------------------------
                           what is currently hardcoded
--------------------------------------------------------------------------------
head       = (xygrid(100px,100px),          # helper grid, then
              declinationGrid(10°),         # draw declination bows, then
              rectascensionGrid(1ʰ))        # draw rectascension lines
stars      =  datafile(“star.DB”)           # datafile
           -> select(HIP, RA, DE, vmag);    # for this purpose use just these four
orionFrame =  projection(Lambert_conformal,5ʰ20ᵐ,10°,10°)
                                            # one of the projections planned
           -> frame(500px,500px);           # select those within 500×500px frame
orionMap   =  (head,
               stars)                       # then stars
           -> orionFrame                    # compute orionFrame position
           -> SVGconverter;                 # then push everything through the SVG filter
--------------------------------------------------------------------------------
                               alternate syntax
--------------------------------------------------------------------------------
   // Items added:
item: xygrid { Δx = 100px, Δy = 100px }
item: declinationgrid { Δδ = 10° }
item: rectascentiongrid { Δα = 1ʰ }
item: data { DBfile = “star.DB” }
   -> select { HIP, α, δ, vmag }
   -> compute { ∅ = (6.8-vmag)*0.8 }

   // Projection:
proj: projection { type = Lambert_conformal, α₀ = 5ʰ20ᵐ, δ₀ = 10°, Δδ = 10° }

================================================================================
                                  Hack plan
================================================================================
	1. encapsulate current code in above direction - make the objects look like
	   above,
	2. insert the current streams as filters in the scheme
	3. soften filter per filter, depending on 

================================================================================
                        Procedure for image generation
================================================================================

1. put up objects (each in its layer)
for each image:
	2. coordinate transformations
    3. image frame/texts
    4. projection/scaling
    5. symbol choice
    6. position/draw
    7. position/draw help text

α. fix parsing/orion.mkm
    i.   5ʰ20ᵐ
    ii.  separate projection (1) and img info (2) — the star “streams” from
         coordinate transformations to projection to image filter

